\chapter{Metodologia}

Nesta seção descrevemos os materiais e a metodologia utilizados para obteção dos resultados apresentados no capítulo 3.

\section{Características técnicas}

Os algorítmos de buscas foram implementados na linguagem C++ e o compilador utilizado foi o g++ (tipo e versão????). O computador onde as simulações foram realizadas possui as seguintes características:
\begin{itemize}
\item[-] MacBook Pro (2014)
\item[-] Processador: 2.5 Ghz Intel Core i7
\item[-] memória: 16 GB 1600 MHz DDR3
\item[-] Placa mãe: ????
\item[-] Sistema operaciona: (tipo e versão????)
\end{itemize}

\section{Algoritmos}

Os algoritmos de busca utilizados nesse estudo estão apresentados aqui com uma breve descrição. Os códigos utilizados encontram-se no apêndice 1. ????


%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Algorithm2e codes %%%

\SetKwProg{Fnc}{Função}{}{fim}
\SetKwFunction{buscaLin}{buscaLin}
\SetKwFunction{buscaBin}{buscaBin\_it}
\SetKwFunction{buscaBinrec}{buscaBin\_rec}
\SetKwFunction{buscaTer}{buscaTer\_it}
\SetKwFunction{buscaTerrec}{buscaTer\_rec}
\SetKwFunction{buscaJump}{buscaJump}
\SetKwFunction{buscaFib}{buscaFib}
\SetKw{Ate}{até}
\SetKw{E}{e}
\SetKwArray{vet}{V}
%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Busca linear}


\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca linear}

  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine

  \Fnc{\buscaLin{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $i$: {\bf inteiro} \;
    \Para{$i \leftarrow l \; \Ate \; r$}{
      \Se{$\vet{i} \; == \; k$}{
        \Retorna{$i$}
      }       
    }

    \Retorna{$-1$}
  }
\end{algorithm}



\subsection{Busca binária}

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca binária iterativa}

  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine

  \Fnc{\buscaBin{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $m$: {\bf inteiro} \tcc{último valor da primeira metade do arranjo} \;
    \Enqto{$r \geq \;l$}{
      $m \leftarrow (l+r)/2$\;
      \uSe{$k \; == \; \vet{m}$}{
        \Retorna{$m$}
      } \uSenaoSe{$k \; < \; \vet{m}$}{
        $r \leftarrow m-1$\;
      } \Senao{
        $l \leftarrow m+1$\;
      }
      
    }

    \Retorna{$-1$}
  }
\end{algorithm}


\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca binária recursiva}

  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine
  
  \Fnc{\buscaBinrec{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $m$: {\bf inteiro} \tcc{último valor da primeira metade do arranjo} \;
    \uSe{$r < \;l$}{
      \Retorna{$-1$}
    } \Senao{

      $m \leftarrow (l+r)/2$\;
      \uSe{$k \; == \; \vet{m}$}{
        \Retorna{$m$}
      } \uSenaoSe{$k \; < \; \vet{m}$}{
        \Retorna \buscaBinrec{$V$,$l$,$m-1$,$k$}\;
      } \Senao{
        \Retorna \buscaBinrec{$V$,$m+1$,$r$,$k$}\;
      }
      
    }

  }
\end{algorithm}



\subsection{Busca ternária}

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca ternária iterativa}

  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine

  \Fnc{\buscaTer{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $t_{1}$: {\bf inteiro} \tcc{último valor do primeiro terço do arranjo}
    {\bf var} $t_{2}$: {\bf inteiro} \tcc{último valor do segundo terço do arranjo} \;
    \Enqto{$r \geq \;l$}{
      $t_{1} \leftarrow l+(r-l)/3$\;
      $t_{2} \leftarrow r-(r-l)/3$\;\;
      \uSe{$k \; == \; \vet{$t_{1}$}$}{
        \Retorna{$t_{1}$}
      } \uSenaoSe{$k \; == \; \vet{$t_{2}$}$}{
        \Retorna{$t_{2}$}
      } \uSenaoSe{$k \; < \; \vet{$t_{1}$}$}{
        $r \leftarrow t_{1}-1$\;
      } \uSenaoSe{$k \; < \; \vet{$t_{2}$}$}{
        $l \leftarrow t_{1}+1$\;
        $r \leftarrow t_{2}-1$\;
      } \Senao{
        $l \leftarrow t_{2}+1$\;
      }
      
    }

    \Retorna{$-1$}
  }
\end{algorithm}


\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca ternária recursiva}

  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine
  
  \Fnc{\buscaTerrec{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $t_{1}$: {\bf inteiro} \tcc{último valor do primeiro terço do arranjo}
    {\bf var} $t_{2}$: {\bf inteiro} \tcc{último valor do segundo terço do arranjo} \;    
    \uSe{$r < \;l$}{
      \Retorna{$-1$}
    } \Senao{
      $t_{1} \leftarrow l+(r-l)/3$\;
      $t_{2} \leftarrow r-(r-l)/3$\;\;
      \uSe{$k \; == \; \vet{$t_{1}$}$}{
        \Retorna{$t_{1}$}
      } \uSenaoSe{$k \; == \; \vet{$t_{2}$}$}{
        \Retorna{$t_{2}$}
      } \uSenaoSe{$k \; < \; \vet{$t_{1}$}$}{
        \Retorna \buscaTerrec{$V$,$l$,$t_{1}-1$,$k$}
      } \uSenaoSe{$k \; < \; \vet{$t_{2}$}$}{
        \Retorna \buscaTerrec{$V$,$t_{1}+1$,$t_{2}-1$,$k$}
      } \Senao{
        \Retorna \buscaTerrec{$V$,$t_{2}+1$,$r$,$k$}
      }
      
    }

  }
\end{algorithm}


\subsection{{\it Jump search}}

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{{\it Jump search}}

  \Entrada{Vetor $\vet$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine

  \Fnc{\buscaJump{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $m$: {\bf inteiro} \;
    {\bf var} $p$: {\bf inteiro} \tcc{tamanho do salto}\;

    $p \leftarrow \sqrt{r-l+1}$\;
    $m \leftarrow l+p$\;
    
    \Enqto{$m \leq r$}{
      \uSe{$k \; == \; \vet{m}$}{
        \Retorna $m$\;
      }\SenaoSe{$k \; < \;\vet{m}$}{
        \Retorna{\buscaLin{$\vet,m-p,m-1,k$}}
      }
      $m \leftarrow m + p$
    }

    \Se{$m>r$ \E $\vet{r} > k$}{
      \Retorna{\buscaLin{$\vet,m-p,r,k$}}
    }

    \Retorna{$-1$}
  }
\end{algorithm}



\subsection{Busca de Fibonacci}


\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca de Fibonacci}
  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine

  \Fnc{\buscaBin{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $size$: {\bf inteiro}\;
    {\bf var} $i$: {\bf inteiro}\;
    {\bf var} $i_{fib1}$: {\bf inteiro}\;
    {\bf var} $fib1$: {\bf inteiro}\;
    {\bf var} $Fib$: {\bf arranjo de inteiros}\;

    $size \leftarrow r-l+1$\;

    \tcc{Calcula a serie de Fibonacci até o i-ésimo termo,\; onde F(i) <= size}
    $Fib[0] \leftarrow 0$\;
    $Fib[1] \leftarrow 1$\;

    $i \leftarrow 1$\;
    \Enqto{ $Fib[i] < size$}{
      $i \leftarrow i + 1$\;
      $Fib[i] \leftarrow Fib[i-1] + Fib[i-2]$\;
    }\;
    
    $i_{fib1} \leftarrow i-2$\;
    \Enqto{$l<r$}{
      
      $fib1 \leftarrow l + F[i_{fib1}]$\;
      \uSe{$k == V[fib1]$}{
        \Retorna $fib1$\;
      } \uSenaoSe{$k < V[fib1]$}{ \tcc{Novos tamanhos das partições à esquerda}
        $r\leftarrow i_{fib1}-1$\;
        $i_{fib1} = i_{fib1}-2$\;
        \Se{$i_{fib1}<0$}{
          $i_{fib1}\leftarrow 0$\;
        }
      } \Senao{ \tcc{Procure os novos tamanhos das partições à direita}
        $l\leftarrow i_{fib1}+1$\;
        $i \leftarrow  \; i_{fib1}+1$\;
        \Enqto{$Fib[i] < r-l+1$}{
            $i \leftarrow i - 1$\;
        }
        $i_{fib1} = i-1$\;
        }
        
      }  
      
    
    \Retorna{$-1$}
  }
\end{algorithm}


\section{Cenários das simulações}

As simulações foram feitas buscando um valor em um conjunto {\it ordenado crescente}. Consideramos o pior caso apenas, ou seja a busca de um valor que não pertence ao conjunto de busca, mas que é maior que o maior elemento neste conjunto.

\section{metodologia}
%% descrição do método ou procedimento empregado para gerar os dados do experimento, quais e como as medições foram tomadas para comparar os algoritmo (tempos, passos, memória)...

Um vetor de inteiros longos de tamanho $10^8$ preenchido com números pares em ordem crescente foi utilizado para gerar as amostras.

Amostras de arranjo

\subsection{Simulações de tempo de execução}

média temporal progressiva...

\subsection{Simulações do número de passos da operação dominante}
