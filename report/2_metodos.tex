\chapter{Metodologia}

Neste capítulo descrevemos ...

\section{Caracterização técnica do computador}

O computador utilizado possui as seguintes características:


\section{Algoritmos}

%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Algorithm2e codes %%%

\SetKwProg{Fnc}{Função}{}{fim}
\SetKwFunction{buscaLin}{buscaLin}
\SetKwFunction{buscaBin}{buscaBin\_it}
\SetKwFunction{buscaBinrec}{buscaBin\_rec}
\SetKwFunction{buscaTer}{buscaTer\_it}
\SetKwFunction{buscaTerrec}{buscaTer\_rec}
\SetKwFunction{buscaJump}{buscaJump}
\SetKwFunction{buscaFib}{buscaFib}
\SetKw{Ate}{até}
\SetKw{E}{e}
\SetKwArray{vet}{V}
%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Busca linear}

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca linear}

  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine

  \Fnc{\buscaLin{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $i$: {\bf inteiro} \;
    \Enqto{$i \leftarrow l \; \Ate \; r$}{
      \Se{$\vet{i} \; == \; k$}{
        \Retorna{$i$}
      }       
    }

    \Retorna{$-1$}
  }
\end{algorithm}



\subsection{Busca binária}

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca binária iterativa}

  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine

  \Fnc{\buscaBin{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $m$: {\bf inteiro} \tcc{último valor da primeira metade do arranjo} \;
    \Enqto{$r \geq \;l$}{
      $m \leftarrow (l+r)/2$\;
      \uSe{$k \; == \; \vet{m}$}{
        \Retorna{$m$}
      } \uSenaoSe{$k \; < \; \vet{m}$}{
        $r \leftarrow m-1$\;
      } \Senao{
        $l \leftarrow m+1$\;
      }
      
    }

    \Retorna{$-1$}
  }
\end{algorithm}


\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca binária recursiva}

  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine
  
  \Fnc{\buscaBinrec{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $m$: {\bf inteiro} \tcc{último valor da primeira metade do arranjo} \;
    \uSe{$r < \;l$}{
      \Retorna{$-1$}
    } \Senao{

      $m \leftarrow (l+r)/2$\;
      \uSe{$k \; == \; \vet{m}$}{
        \Retorna{$m$}
      } \uSenaoSe{$k \; < \; \vet{m}$}{
        \Retorna \buscaBinrec{$V$,$l$,$m-1$,$k$}\;
      } \Senao{
        \Retorna \buscaBinrec{$V$,$m+1$,$r$,$k$}\;
      }
      
    }

  }
\end{algorithm}



\subsection{Busca ternária}

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca ternária iterativa}

  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine

  \Fnc{\buscaTer{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $t_{1}$: {\bf inteiro} \tcc{último valor do primeiro terço do arranjo}
    {\bf var} $t_{2}$: {\bf inteiro} \tcc{último valor do segundo terço do arranjo} \;
    \Enqto{$r \geq \;l$}{
      $t_{1} \leftarrow l+(r-l)/3$\;
      $t_{2} \leftarrow r-(r-l)/3$\;\;
      \uSe{$k \; == \; \vet{$t_{1}$}$}{
        \Retorna{$t_{1}$}
      } \uSenaoSe{$k \; == \; \vet{$t_{2}$}$}{
        \Retorna{$t_{2}$}
      } \uSenaoSe{$k \; < \; \vet{$t_{1}$}$}{
        $r \leftarrow t_{1}-1$\;
      } \uSenaoSe{$k \; < \; \vet{$t_{2}$}$}{
        $l \leftarrow t_{1}+1$\;
        $r \leftarrow t_{2}-1$\;
      } \Senao{
        $l \leftarrow t_{2}+1$\;
      }
      
    }

    \Retorna{$-1$}
  }
\end{algorithm}


\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca ternária recursiva}

  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine
  
  \Fnc{\buscaTerrec{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $t_{1}$: {\bf inteiro} \tcc{último valor do primeiro terço do arranjo}
    {\bf var} $t_{2}$: {\bf inteiro} \tcc{último valor do segundo terço do arranjo} \;    
    \uSe{$r < \;l$}{
      \Retorna{$-1$}
    } \Senao{
      $t_{1} \leftarrow l+(r-l)/3$\;
      $t_{2} \leftarrow r-(r-l)/3$\;\;
      \uSe{$k \; == \; \vet{$t_{1}$}$}{
        \Retorna{$t_{1}$}
      } \uSenaoSe{$k \; == \; \vet{$t_{2}$}$}{
        \Retorna{$t_{2}$}
      } \uSenaoSe{$k \; < \; \vet{$t_{1}$}$}{
        \Retorna \buscaTerrec{$V$,$l$,$t_{1}-1$,$k$}
      } \uSenaoSe{$k \; < \; \vet{$t_{2}$}$}{
        \Retorna \buscaTerrec{$V$,$t_{1}+1$,$t_{2}-1$,$k$}
      } \Senao{
        \Retorna \buscaTerrec{$V$,$t_{2}+1$,$r$,$k$}
      }
      
    }

  }
\end{algorithm}


\subsection{{\it Jump search}}

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{{\it Jump search}}

  \Entrada{Vetor $\vet$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine

  \Fnc{\buscaJump{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $m$: {\bf inteiro} \;
    {\bf var} $p$: {\bf inteiro} \tcc{tamanho do salto}\;

    $p \leftarrow \sqrt{r-l+1}$\;
    $m \leftarrow l+p$\;
    
    \Enqto{$m \leq r$}{
      \uSe{$k \; == \; \vet{m}$}{
        \Retorna $m$\;
      }\SenaoSe{$k \; < \;\vet{m}$}{
        \Retorna{\buscaLin{$\vet,m-p,m-1,k$}}
      }
      $m = m + p$
    }

    \Se{$m>r$ \E $\vet{r} > k$}{
      \Retorna{\buscaLin{$\vet,m-p,r,k$}}
    }

    \Retorna{$-1$}
  }
\end{algorithm}



\subsection{Busca de Fibonacci}


\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca de Fibonacci}

  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine

  \Fnc{\buscaBin{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{

    \Retorna{$-1$}
  }
\end{algorithm}


\section{Cenários das simulações}

Amostras de arranjo

Um vetor de inteiros longos de tamanho $10^8$ preenchido com números pares em ordem crescente foi utilizado para gerar as amostras.

\subsection{Simulações de tempo de execução}

média temporal progressiva...

\subsection{Simulações do número de passos da operação dominante}
