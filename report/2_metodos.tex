\chapter{Metodologia}

Nesta seção descrevemos os materiais e a metodologia utilizados para obteção dos resultados apresentados no capítulo 3.

\section{Características técnicas}

Os algorítmos de buscas foram implementados na linguagem C++ e o compilador utilizado foi o g++ (tipo e versão????). O computador onde as simulações foram realizadas possui as seguintes características:
\begin{itemize}
\item[-] MacBook Pro (2014)
\item[-] Processador: 2.5 Ghz Intel Core i7
\item[-] memória: 16 GB 1600 MHz DDR3
\item[-] Placa mãe: ????
\item[-] Sistema operaciona: (tipo e versão????)
\end{itemize}

\section{Algoritmos}

Dado um arranjo sequencial $V$, cujos elementos estão ordenado em {\it ordem crescente} (sem repetição) e um valor chave $k$, os algoritmos aqui descritos tem como objetivo retornar o índice da localização de $k$ em $V$, caso este valor não esteja presente no arranjo, devem retornar $-1$. Os códigos utilizados no estudo baseados nesses algoritmos encontram-se no apêndice 1. ????


%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Algorithm2e codes %%%

\SetKwProg{Fnc}{Função}{}{fim}
\SetKwFunction{buscaLin}{buscaLin}
\SetKwFunction{buscaBin}{buscaBin\_it}
\SetKwFunction{buscaBinrec}{buscaBin\_rec}
\SetKwFunction{buscaTer}{buscaTer\_it}
\SetKwFunction{buscaTerrec}{buscaTer\_rec}
\SetKwFunction{buscaJump}{buscaJump}
\SetKwFunction{buscaFib}{buscaFib}
\SetKw{Ate}{até}
\SetKw{E}{e}
\SetKwArray{vet}{V}
%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Busca linear}

A busca linear varre o arranjo do primeiro ao último elemento comparando, a cada passo da varredura, o valor selecionado no arranjo com a chave procurada. Se encontrar a chave interrompe a busca e retorna o índice atual, senão, a varredura continua até o fim do arranjo. Seu pior caso por tanto, é quando o valor procurado é maior ou igual ao último elemento do arranjo.

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca linear}

  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine

  \Fnc{\buscaLin{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $i$: {\bf inteiro} \;
    \Para{$i \leftarrow l \; \Ate \; r$}{
      \Se{$\vet{i} \; == \; k$}{
        \Retorna{$i$}
      }       
    }

    \Retorna{$-1$}
  }
\end{algorithm}



\subsection{Busca binária}

Na busca binária, particiona-se o arranjo em dois, selecionando o elemento do meio. Caso este seja igual ao valor procurado, interrompe-se a busca retornado o valor do índice encontrado, caso contrário, uma comparação é feita a fim de determinar se o valor é maior ou menor do que o elemento selecionado, determinando assim em qual metade deve-se fazer a busca novamente. A nova busca repete o mesmo procedimento descrito anteriormente até que o elemento seja encontrado ou, caso a partição analizada seja igual a zero e o valor não tiver sido encontrado, o algoritmo retorna $-1$. O pior caso é aquele em que $k$ não pertence ao arranjo ou é o último elemento buscado.

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca binária iterativa}

  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine

  \Fnc{\buscaBin{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $m$: {\bf inteiro} \tcc{último valor da primeira metade do arranjo} \;
    \Enqto{$r \geq \;l$}{
      $m \leftarrow (l+r)/2$\;
      \uSe{$k \; == \; \vet{m}$}{
        \Retorna{$m$}
      } \uSenaoSe{$k \; < \; \vet{m}$}{
        $r \leftarrow m-1$\;
      } \Senao{
        $l \leftarrow m+1$\;
      }
      
    }

    \Retorna{$-1$}
  }
\end{algorithm}


\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca binária recursiva}

  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine
  
  \Fnc{\buscaBinrec{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $m$: {\bf inteiro} \tcc{último valor da primeira metade do arranjo} \;
    \uSe{$r < \;l$}{
      \Retorna{$-1$}
    } \Senao{

      $m \leftarrow (l+r)/2$\;
      \uSe{$k \; == \; \vet{m}$}{
        \Retorna{$m$}
      } \uSenaoSe{$k \; < \; \vet{m}$}{
        \Retorna \buscaBinrec{$V$,$l$,$m-1$,$k$}\;
      } \Senao{
        \Retorna \buscaBinrec{$V$,$m+1$,$r$,$k$}\;
      }
      
    }

  }
\end{algorithm}



\subsection{Busca ternária}

A busca ternário se assemelha a busca binária, com a diferença que divide o arranjo em 3 partes, selecionando o maior elemento do primeiro terço do arranjo $t_1$ e o maior do segundo terço $t_2$. Em seguida, verifica-se se algum desses elementos é o valor procurado $k$. Caso seja, retorna o índice do elemento no arranjo, caso não, realiza-se o mesmo procedimento no terço que possivelmente contém o valor procurado, ou seja, se $k<t_1$, faz-se a busca ternária no primeiro terço, se $t_1<k<t_2$ busca-se no segundo terço, senão a busca é feita no último terço. Novamente o pior caso é aquele em que $k$ não pertence ao arranjo ou é o último elemento buscado.

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca ternária iterativa}

  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine

  \Fnc{\buscaTer{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $t_{1}$: {\bf inteiro} \tcc{último valor do primeiro terço do arranjo}
    {\bf var} $t_{2}$: {\bf inteiro} \tcc{último valor do segundo terço do arranjo} \;
    \Enqto{$r \geq \;l$}{
      $t_{1} \leftarrow l+(r-l)/3$\;
      $t_{2} \leftarrow r-(r-l)/3$\;\;
      \uSe{$k \; == \; \vet{$t_{1}$}$}{
        \Retorna{$t_{1}$}
      } \uSenaoSe{$k \; == \; \vet{$t_{2}$}$}{
        \Retorna{$t_{2}$}
      } \uSenaoSe{$k \; < \; \vet{$t_{1}$}$}{
        $r \leftarrow t_{1}-1$\;
      } \uSenaoSe{$k \; < \; \vet{$t_{2}$}$}{
        $l \leftarrow t_{1}+1$\;
        $r \leftarrow t_{2}-1$\;
      } \Senao{
        $l \leftarrow t_{2}+1$\;
      }
      
    }

    \Retorna{$-1$}
  }
\end{algorithm}


\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca ternária recursiva}

  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine
  
  \Fnc{\buscaTerrec{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $t_{1}$: {\bf inteiro} \tcc{último valor do primeiro terço do arranjo}
    {\bf var} $t_{2}$: {\bf inteiro} \tcc{último valor do segundo terço do arranjo} \;    
    \uSe{$r < \;l$}{
      \Retorna{$-1$}
    } \Senao{
      $t_{1} \leftarrow l+(r-l)/3$\;
      $t_{2} \leftarrow r-(r-l)/3$\;\;
      \uSe{$k \; == \; \vet{$t_{1}$}$}{
        \Retorna{$t_{1}$}
      } \uSenaoSe{$k \; == \; \vet{$t_{2}$}$}{
        \Retorna{$t_{2}$}
      } \uSenaoSe{$k \; < \; \vet{$t_{1}$}$}{
        \Retorna \buscaTerrec{$V$,$l$,$t_{1}-1$,$k$}
      } \uSenaoSe{$k \; < \; \vet{$t_{2}$}$}{
        \Retorna \buscaTerrec{$V$,$t_{1}+1$,$t_{2}-1$,$k$}
      } \Senao{
        \Retorna \buscaTerrec{$V$,$t_{2}+1$,$r$,$k$}
      }
      
    }

  }
\end{algorithm}


\subsection{{\it Jump search}}

Na {\it Jump search}, uma varredura em saltos de tamanho $m$ ($0< m < n$, com $n$ o tamanho do vetor) é realizada. Na primeira iteração, compara-se o $m$-ésimo elemento ao valor buscado, caso seja igual, retorna-se $m$, se for menor, uma busca linear é realizada neste bloco do arranjo, caso contrário, a varredura passa para o $(m+1)$-ésimo elemento onde se procede da mesma maneira. Caso a busca chegue ao último elemento do vetor sem encontrar o valor chave, o valor de retorno é $-1$. Aqui o pior caso é quando o valor procurado é maior ou igual ao último elemento do arranjo.

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{{\it Jump search}}

  \Entrada{Vetor $\vet$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine

  \Fnc{\buscaJump{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $m$: {\bf inteiro} \;
    {\bf var} $p$: {\bf inteiro} \tcc{tamanho do salto}\;

    $p \leftarrow \sqrt{r-l+1}$\;
    $m \leftarrow l+p$\;
    
    \Enqto{$m \leq r$}{
      \uSe{$k \; == \; \vet{m}$}{
        \Retorna $m$\;
      }\SenaoSe{$k \; < \;\vet{m}$}{
        \Retorna{\buscaLin{$\vet,m-p,m-1,k$}}
      }
      $m \leftarrow m + p$
    }

    \Se{$m>r$ \E $\vet{r} > k$}{
      \Retorna{\buscaLin{$\vet,m-p,r,k$}}
    }

    \Retorna{$-1$}
  }
\end{algorithm}



\subsection{Busca de Fibonacci}

A busca de Fibonacci procede da mesma forma que a busca binária, mas particiona o arranjo em duas partes de tamanho diferente. O tamanho da primeira partição é o menor número da série de Fibonacci $F(i)$ tal que o tamanho do arranjo $n$ é maior ou igual a $Fib(i+2)$. O pior caso é aquele em que $k$ não pertence ao arranjo ou é o último elemento buscado. ????

\begin{algorithm}[H]
  \DontPrintSemicolon
  \SetAlgoLined
  \caption{Busca de Fibonacci}
  \Entrada{Vetor $V$, chave $k$ e limites de busca esquerdo $l$ e direito $r$ (inclusive).}
  \Saida{Índice da ocorrência de $k$ em $V$; ou $-1$ caso não exista $k$ em $V$.}
  \tcc{Precondição: $l \leq r$; $l,r \geq 0$; $V$ em ordem crescente.}  
  \BlankLine

  \Fnc{\buscaBin{$V$: {\bf arranjo de inteiros}; $l$: {\bf inteiro}; $r$: {\bf inteiro}; $k$: {\bf inteiro}}: {\bf inteiro}}{
    {\bf var} $size$: {\bf inteiro}\;
    {\bf var} $i$: {\bf inteiro}\;
    {\bf var} $i_{fib1}$: {\bf inteiro}\;
    {\bf var} $fib1$: {\bf inteiro}\;
    {\bf var} $Fib$: {\bf arranjo de inteiros}\;

    $size \leftarrow r-l+1$\;

    \tcc{Calcula a serie de Fibonacci até o i-ésimo termo,\; onde F(i) <= size}
    $Fib[0] \leftarrow 0$\;
    $Fib[1] \leftarrow 1$\;

    $i \leftarrow 1$\;
    \Enqto{ $Fib[i] < size$}{
      $i \leftarrow i + 1$\;
      $Fib[i] \leftarrow Fib[i-1] + Fib[i-2]$\;
    }\;
    
    $i_{fib1} \leftarrow i-2$\;
    \Enqto{$l<r$}{
      
      $fib1 \leftarrow l + F[i_{fib1}]$\;
      \uSe{$k == V[fib1]$}{
        \Retorna $fib1$\;
      } \uSenaoSe{$k < V[fib1]$}{ \tcc{Novos tamanhos das partições à esquerda}
        $r\leftarrow fib1-1$\;
        $i_{fib1} = i_{fib1}-2$\;
        \Se{$i_{fib1}<0$}{
          $i_{fib1}\leftarrow 0$\;
        }
      } \Senao{ \tcc{Procure os novos tamanhos das partições à direita}
        $l\leftarrow fib1+1$\;
        $i \leftarrow  \; i_{fib1}+1$\;
        \Enqto{$Fib[i] < r-l+1$}{
            $i \leftarrow i - 1$\;
        }
        $i_{fib1} = i-1$\;
        }
        
      }  
      
    
    \Retorna{$-1$}
  }
\end{algorithm}


\section{Cenários das simulações}

As simulações foram feitas buscando um valor em um conjunto {\it ordenado crescente}. Consideramos o pior caso apenas. Portanto, para todos os algoritmos selecionados, podemos escolher como pior caso a busca de um valor que não pertence ao conjunto de busca e é maior que o maior elemento neste conjunto.

\section{metodologia}
%% descrição do método ou procedimento empregado para gerar os dados do experimento, quais e como as medições foram tomadas para comparar os algoritmo (tempos, passos, memória)...

Para comparar os diferentes algoritmos de busca, simulações do tempo de execução para diferentes tamanhos de arranjos de entrada foram feitas. Também para análisar a diferença entre a implementação iterativa e recursiva do algoritmo ....???? foram feitas simulações medindo o número de passos da operação dominante. 


Um vetor de inteiros longos de tamanho $10^8$ preenchido com números pares em ordem crescente foi utilizado para gerar as amostras. 

50 amostras do vetor foram utilizadas com tamanhos variando de 100 até $10^8$, com crescimento linear. ????

\subsection{Simulações de tempo de execução}

Utilizou-se a biblioteca Chronos com precisão de microsegundos para medir o tempo antes e depois da execução de cada algoritmo de busca.

Para suavizar as flutuações temporais, o tempo levado em cada amostra foi medido 100 vezes e apenas a média progressiva foi registrada. A fórmula da média temporal progressiva foi utilizada para evitar erros de arredondamento e é dada pela seguinte fórmula recusiva:
\begin{eqnarray}
&&M_0 = 0, \nonumber \\
&&M_k = M_{k-1} + \frac{x_k-M_{k-1}}{k},
\end{eqnarray}
onde $x_k$ é o tempo mensurado para a $k$-ésima execução e $M_{k=m}$ corresponde a média aritmética.


\subsection{Simulações do número de passos da operação dominante}
